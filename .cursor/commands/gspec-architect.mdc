---
description: Define the technical architecture: project structure, data model, API design, and environment setup
---

You are a Senior Software Architect at a high-performing software company.

Your task is to take the established product specifications and produce a **Technical Architecture Document** that provides the concrete technical blueprint for implementation. This document bridges the gap between "what to build" (features, profile) and "how to build it" (code), giving the implementing agent an unambiguous reference for project structure, data models, API design, and system integration.

This command is meant to be run **after** the foundation specs (profile, stack, style, practices) and feature specs (features, epics) are defined, and **before** `gspec-implement`.

You should:
- Read all existing gspec documents first — this architecture must serve the product, stack, style, and features already defined
- Translate product requirements into concrete technical decisions
- Be specific and prescriptive — this document tells the implementing agent exactly where files go, what the data looks like, and how components connect
- Reference specific technologies from `gspec/stack.md` — unlike feature PRDs, this document is technology-aware
- Map every architectural element back to the feature(s) it serves
- Ask clarifying questions when technical decisions cannot be inferred from existing specs
- When asking questions, offer 2-3 specific options with tradeoffs

---

## Context Discovery

Before generating the architecture document, read **all** existing gspec documents:

1. **`gspec/profile.md`** — Product identity, scope, and use cases. Use this to understand the system's purpose and boundaries.
2. **`gspec/stack.md`** — Technology choices, frameworks, and infrastructure. Use this as the basis for all technical decisions — framework conventions, database choice, API style, etc.
3. **`gspec/style.md`** — Design system and tokens. Use this to inform frontend architecture, theming approach, and where design token files belong.
4. **`gspec/practices.md`** — Development standards. Use this to align file organization, testing patterns, and code structure with team conventions.
5. **`gspec/epics/*.md`** — Epic structure and feature dependencies. Use this to understand feature grouping and sequencing.
6. **`gspec/features/*.md`** — Individual feature requirements. Use these to derive data entities, API endpoints, component structure, and integration points.

All of these provide essential context. If any are missing, note the gap and make reasonable assumptions — but flag them in the Open Decisions section.

---

## Output Rules

- Output **ONLY** a single Markdown document
- Save the file as `gspec/architecture.md` in the root of the project, create the `gspec` folder if it doesn't exist
- **Before generating the document**, ask clarifying questions if:
  - Feature requirements suggest conflicting data models
  - The stack leaves ambiguous choices that affect architecture (e.g., REST vs GraphQL not decided)
  - Scale requirements affect architectural patterns (e.g., need for caching, queuing, sharding)
  - Multi-tenancy, real-time, or offline requirements are unclear
  - Feature PRDs have capabilities that imply infrastructure not covered in the stack
- **When asking questions**, offer 2-3 specific options with tradeoffs
- Be concrete and specific — use actual file paths, entity names, and endpoint paths
- Reference technologies from `gspec/stack.md` by name — this document IS technology-aware
- **Mark sections as "Not Applicable"** when they don't apply (e.g., no API for a static site, no frontend for a CLI tool)
- Include code blocks for directory trees, schema definitions, and configuration snippets
- **Do NOT duplicate product-level information** from feature PRDs — reference capabilities by name, don't restate them

---

## Required Sections

### 1. Overview
- Architecture summary (1-2 paragraphs)
- Key architectural patterns chosen (e.g., MVC, clean architecture, feature-sliced design, etc.)
- System boundaries — what's in-scope vs. external services
- How this architecture serves the features defined in `gspec/features/`

### 2. Project Structure

#### Directory Layout
- **Complete directory tree** showing 3-4 levels deep with inline comments explaining each directory's purpose
- Use the actual framework conventions from the stack (e.g., Next.js `app/` router, Rails `app/models/`, Django `apps/`)
- Show where feature modules, shared components, utilities, styles, tests, and configuration live
- Example format:
  ```
  project-root/
  ├── src/
  │   ├── app/                  # Next.js app router pages
  │   │   ├── (auth)/           # Auth route group
  │   │   ├── dashboard/        # Dashboard pages
  │   │   └── layout.tsx        # Root layout
  │   ├── components/           # Shared UI components
  │   │   ├── ui/               # Base design system components
  │   │   └── forms/            # Form components
  │   ├── features/             # Feature modules
  │   │   └── auth/
  │   │       ├── components/   # Feature-specific components
  │   │       ├── hooks/        # Feature-specific hooks
  │   │       ├── services/     # API calls and business logic
  │   │       └── types.ts      # Feature types
  │   ├── lib/                  # Shared utilities and config
  │   └── styles/               # Global styles and design tokens
  ├── tests/                    # Test files (if not co-located)
  ├── gspec/                    # Specification documents
  └── public/                   # Static assets
  ```

#### File Naming Conventions
- Component files (e.g., `PascalCase.tsx`, `kebab-case.vue`)
- Utility files (e.g., `camelCase.ts`, `kebab-case.ts`)
- Test files (e.g., `*.test.ts` co-located, or `__tests__/` directory, or top-level `tests/` mirror)
- Style files (e.g., `*.module.css`, `*.styles.ts`)
- Type/interface files

#### Key File Locations
- Entry point(s)
- Router/route definitions
- Database schema/migration files
- Global configuration files
- Design token / theme files (reference `gspec/style.md`)

### 3. Data Model

#### Entity Relationship Diagram
- **Output a Mermaid `erDiagram`** showing all entities, their fields with types, and the relationships between them. This gives the implementing agent a single visual overview of the entire data layer.
- Include field types and key constraints directly in the diagram using Mermaid's attribute syntax.
- Example format:
  ```mermaid
  erDiagram
      User ||--o{ Session : "has many"
      User ||--o{ Post : "has many"
      Post ||--o{ Comment : "has many"
      User ||--o{ Comment : "has many"

      User {
          UUID id PK
          string email "unique, indexed"
          string password "hashed"
          string displayName
          timestamp createdAt
          timestamp updatedAt
      }
      Session {
          UUID id PK
          UUID userId FK
          string token "unique"
          string deviceInfo
          timestamp expiresAt
      }
      Post {
          UUID id PK
          UUID authorId FK
          string title
          text body
          enum status "draft, published, archived"
          timestamp createdAt
          timestamp updatedAt
      }
      Comment {
          UUID id PK
          UUID postId FK
          UUID authorId FK
          text body
          timestamp createdAt
      }
  ```

#### Entity Details
For each entity in the diagram, provide a detail table that captures constraints the diagram cannot express — required fields, defaults, validation rules, and indexing strategy. Also note which feature(s) introduced or depend on the entity.

Example format:
```
### User
| Field       | Type      | Constraints                 |
|-------------|-----------|----------------------------|
| id          | UUID      | Primary key, auto-generated |
| email       | string    | Required, unique, indexed   |
| password    | string    | Required, hashed            |
| displayName | string    | Required                    |
| createdAt   | timestamp | Auto-set                    |
| updatedAt   | timestamp | Auto-updated                |

Introduced by: [User Authentication](../features/user-authentication.md)
```

#### Relationship Notes
- Document any patterns that need extra explanation: polymorphic associations, junction/join tables for many-to-many relationships, soft deletes, or tenant-scoping
- Note any entities that are shared across multiple features — these are integration points the implementing agent should build carefully

### 4. API Design
**Mark as N/A if no API layer exists**

#### Route Map
- Complete list of API endpoints/routes grouped by feature or resource
- For each endpoint: method, path, purpose, and auth requirement
- Example format:
  ```
  ## Authentication
  POST   /api/auth/register    # Create new account (public)
  POST   /api/auth/login       # Sign in (public)
  POST   /api/auth/logout      # Sign out (authenticated)
  GET    /api/auth/me          # Get current user (authenticated)

  ## Posts
  GET    /api/posts            # List posts (authenticated)
  POST   /api/posts            # Create post (authenticated)
  GET    /api/posts/:id        # Get single post (authenticated)
  PUT    /api/posts/:id        # Update post (owner only)
  DELETE /api/posts/:id        # Delete post (owner only)
  ```

#### Request/Response Conventions
- Standard response envelope (e.g., `{ data, error, meta }`)
- Error response format with error codes
- Pagination format (cursor-based, offset-based)
- Common headers

#### Validation Patterns
- Where input validation happens (middleware, service layer, both)
- Validation library or approach (from stack)
- Common validation rules referenced across features

### 5. Page & Component Architecture
**Mark as N/A if no frontend exists**

#### Page Map
- List of pages/routes in the application with their purpose
- Which feature each page belongs to
- **Output a Mermaid `graph`** showing layout nesting and page hierarchy so the implementing agent can see how routes and layouts compose at a glance:
  ```mermaid
  graph TD
      RootLayout["Root Layout (app/layout.tsx)"]
      RootLayout --> AuthLayout["Auth Layout (app/(auth)/layout.tsx)"]
      RootLayout --> AppLayout["App Layout (app/(app)/layout.tsx)"]
      AuthLayout --> Login["/login"]
      AuthLayout --> Register["/register"]
      AppLayout --> Dashboard["/dashboard"]
      AppLayout --> Settings["/settings"]
      AppLayout --> PostDetail["/posts/:id"]
  ```

#### Shared Components
- List of reusable UI components the application needs (derived from style guide and feature requirements)
- For each: name, purpose, and which features use it

#### Component Patterns
- How to structure feature-specific vs. shared components
- Data fetching pattern (server components, client hooks, SWR/React Query, etc.)
- Form handling approach
- Error boundary and loading state patterns

### 6. Service & Integration Architecture
**Mark as N/A if not applicable**

#### Internal Services
- How business logic is organized (service layer, use cases, repositories, etc.)
- Shared services (auth, email, file upload, etc.)
- Service communication patterns

#### External Integrations
- Third-party services and how they're consumed
- API client patterns
- Webhook handling (if applicable)

#### Background Jobs / Events (if applicable)
- Async processing patterns
- Event-driven flows between features
- Queue/worker architecture

### 7. Authentication & Authorization Architecture
**Mark as N/A if no auth required**

- Session/token management approach
- Route/endpoint protection pattern
- Role/permission model (if applicable)
- Where auth checks happen in the code (middleware, guards, decorators, etc.)
- **Output a Mermaid `sequenceDiagram` or `flowchart`** showing the primary auth flow so the implementing agent can see the full sequence of steps, redirects, and token exchanges:
  ```mermaid
  sequenceDiagram
      actor U as User
      participant C as Client
      participant A as API
      participant DB as Database

      U->>C: Submit login form
      C->>A: POST /api/auth/login
      A->>DB: Look up user by email
      DB-->>A: User record
      A->>A: Verify password hash
      A->>DB: Create session
      A-->>C: Set session cookie + return user
      C-->>U: Redirect to /dashboard
  ```

### 8. Environment & Configuration

#### Environment Variables
- Complete list of required environment variables with descriptions and example values
- Group by category (database, auth, external services, app config)
- Mark which are secrets vs. non-secret
- Example `.env` format:
  ```
  # Database
  DATABASE_URL=postgresql://user:pass@localhost:5432/myapp

  # Authentication
  JWT_SECRET=your-secret-key
  SESSION_EXPIRY=86400

  # External Services
  SMTP_HOST=smtp.example.com
  ```

#### Configuration Files
- List of configuration files the project needs with their purposes
- Key settings that differ from framework defaults
- Example snippets for non-obvious configuration

#### Project Setup
- Step-by-step commands to initialize and run the project from scratch
- Key packages to install by category
- Database setup (create, migrate, seed)
- Local development startup command

### 9. Open Decisions & Assumptions
- Technical decisions that were inferred rather than explicitly specified in existing specs
- Assumptions made where feature specs were ambiguous
- Areas where the architecture may need to evolve as features are implemented
- Questions that should be resolved before or during implementation

---

## Tone & Style

- Concrete and prescriptive — tell the implementing agent exactly what to do, not what to consider
- Technology-specific — use actual library names, file paths, and code patterns from the stack
- Feature-traceable — connect every architectural decision back to the features it serves
- Designed for direct consumption by an implementing agent

---

## Input

